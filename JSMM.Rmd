---
title: "JSMM-Rcode"
author: "Otso Ovaskainen, Danielle Leal Ramos, Marco Aurelio Pizo, Milton Cezar Ribeiro and Juan Manuel Morales"
date: "November 5, 2017"
output: html_document
---

This is a demonstration of the Joint Species Movement Model, applied for data on birds movement in a heterogeneous landscape.

The script uses the following packages:

```{r}
## Required packages
if (!require("MCMCpack")) install.packages("MCMCpack") # for function riwish
if (!require("mvtnorm")) install.packages("mvtnorm") # for functions dmvnorm and rmvnorm
```

First, we organize the landscape and movement data. The landscape data consists of a matrix with one value for each landscape cell: $1$ for pasture (open areas), $2$ for semi-open (narrow corridors of treees, single trees, and small group of trees outside forest patches), and $3$ for forest habitat. We transform this into two indicator variable ($s$ and $f$ in the main text) for semi-open and forest habitats respectively.

```{r}
habitat <- read.table("type_pa.csv", sep = ",")
s <- numeric(length(habitat$V1))
f <- numeric(length(habitat$V1))
s[which(habitat$V1 == 2)] <- 1
f[which(habitat$V1 == 3)] <- 1
```

Now we generate a matrix $d$ of the Euclidean distances between cells in the landscape (in tens of meters).

```{r}
xp <- rep(c(1:60), 60)        # x coordinates
yp <- rep(c(60:1), each = 60) # y coordinates
xv <- cbind(xp, yp)
d  <- unname(as.matrix(dist(xv, upper = TRUE, diag = TRUE)) )
```

Now, we read the bird species data: the movement tracks, the species traits and the phylogenetic correlation matrix.

The first column (SPS) of the track data contains the species name, the second column (TID) holds the track identification number, and the third (TA) contains the sequence of used landscape cells. We included only species with traits and phylogenetic correlation values, and only tracks inside the landscape and with at least two resting cells (i.e. at least one "move").

```{r}
tracks <- read.table("tracks.csv", sep = ",", header = TRUE)

## Phylogenetic correlation matrix (optional)
CC <- read.table("CC.csv", sep = ",", header = FALSE)
CC <- apply(CC, FUN = as.numeric, MARGIN = 1)

## Species traits (optional)
ttraits <- read.table("traits.csv", sep = ",", header = TRUE)

TT <- matrix(0, nrow = nrow(ttraits), ncol = length(unique(ttraits[ , 2])) + 1) # contains the traits (columns) for each species (rows). Cathegorical traits are converted to binomial variables.

colpos = as.numeric(ttraits[ , 2])
for(i in 1:nrow(TT)){
  TT[i, colpos[i]] = 1 
}

TT[ , ncol(TT)] = log(ttraits[ , 3]) # Log body mass

## Note: the sequence of species in TT and CC matrix need to be the same, and the parameters of all species described in TT and CC will be estimated.
```

To fit the movement model to the data, first we define the likelihood function. Here, we use a simple step-selection model. This function should be adapted to be used for other movement data, keeping 3 groups of arguments: (1) the vector $theta$ with the species-specific parameters to be tested; (2) the species movement data ($tracks$); and (3) the environmental covariates ($s$, $f$, and $d$).

```{r}
## Likelihood function with three arguments: vector theta with species-specific parameters, species movement data (tracks), and environmental covariates (s, f, d).

likelihood <- function(theta = theta, tracks = tracks, s = s, f = f, d = d){
  
  ## theta is a 3 x 1 vector with the species-specific parameters for species k
  alpha  <- exp(theta[1]) # typical step length made by species k
  beta_s <- theta[2] # affinity of the species k to the semi-open habitat compared to the open areas
  beta_f <- theta[3] # affinity of the species k to the forest habitat compared to the open areas
  
  li <- 0
  
  idt <- tracks[ , 2] # track identity
  uid <- unique(idt)
  ta  <- tracks[ , 3] # sequence of perch positions
  
  if(length(uid) == 0){
    li = 0
  }else{
    
    for(ss in 1: length(uid)){ # for each one of the tracks
      lta <- ta[idt == uid[ss]]
      
      for(i in 1: (length(lta) - 1)){ #for each movement destination
        pr <- exp(-d[lta[i], ]/alpha) * exp(beta_s * s) * exp(beta_f * f)
        pr <- pr / sum(pr)
        pr <- pr + 10^(-10)
        pr <- pr / sum(pr)
        li <- li + log(pr[lta[i + 1]])
      }
    }
  }
  return(li)
}
```

Now we set up some variables. 

```{r}
includePhylogeny <- TRUE
includeTraits <- TRUE
if (missing(CC)) includePhylogeny <- FALSE
if (missing(TT)) includeTraits <- FALSE

parameters <- c("log movement distance", "matrix' tree cover affinity", "forest affininity") # species-specific parameters
np  <- length(parameters) # number of species-specific parameters
SPS <- tracks[ , 1]  # species
SP  <- unique(SPS)   # sequence of studied species
ns  <- length(SP)    # number of studied species

## To include the intercept into the model, we set TT[,1] <- 1 for all species. In the absence of trait information, only the intercept is included.
if(!includeTraits){
  TT <- matrix(1, nrow = ns)
  nt <- 1
  traits <- "intercept"
}

if(includeTraits){
  TT <- TT
  nt <- ncol(TT)
  #if(!is.na(colnames(TT)))
  traits <- colnames(TT)
}
```

Now we define the prior distributions for all parameters. For the matrix **Z**, which measures the influence of the species-specific traits to the movement parameters, we use a multivariate normal distribution with zero mean and an identity matrix as the variance-covariance: $\text{vec} \left( \mathbf{Z} \right) \sim N \left( \mu_z = \mathbf{0}, \Sigma_z = \mathbb{I} \right)$. The prior for the the residual variation $\mathbf{\Sigma}$ is an Inverse-Wishart distribution, $\mathbf{\Sigma} \sim W^{-1}\left( \mathbf{\Psi} , \nu  \right)$ with the degrees of freedom set to the number of parameters ($\nu = n_p$) and the scale matrix $\mathbf{\Psi}$ set to the identity matrix. For $\rho$ we used a uniform distribution between $0$ and $1$ discretized into $100$ values and we pre-computed the determinants and inverse of the variance-covariance matrices used in the conditional sampling (see MCMC below). 

```{r}
## Zeta
mu_z <- matrix(0, nrow = np * nt)
S_z  <- diag(np * nt)

## Sigma
PSI <- diag(np)
nu  <- np

## Rho
if(includePhylogeny){
  rhos <- seq(0, 1, 0.01)
  nr   <- length(rhos)
  priorRho  <- rep(1/nr, nr)
  lpriorRho <- log(priorRho)
  iWs <- array(dim = c(ns, ns, nr))
  ldetWs <- numeric(nr)
  
  for(i in 1: nr){
    W <- rhos[i] * CC + (1 - rhos[i]) * diag(ns)
    iWs[ , , i] <- solve(W)
    ldetWs[i]   <- log(det(as.matrix(W)))
  }
}
```

To fit the model to the data, we developed a Markov chain Monte Carlo (MCMC) sampling scheme that uses a Metropolis-Hastings step to sample the species-specific parameters Theta, whereas the parameters Zeta, Sigma and rho are sampled directly from their full conditional distribution.  
Before running the MCMC we set initial values for the parameters to be estimated: Theta, Sigma, Zeta, and rho.

```{r}
Theta <- matrix(0, nrow = ns, ncol = np)
Sigma  <- diag(np)  # identity matrix
iSI <- solve(Sigma) # inverse of matrix Sigma
Z   <- matrix(0, nrow = nt, ncol = np)
M   <- TT %*% Z   # mu_k; expected values of THETA
X   <- TT %x% diag(np)

if(includePhylogeny){
  RI <- round(nr/2)
  rho <- rhos[RI]
  iW <- iWs[ , ,RI]
  ldetW <- ldetWs[RI]
}

if(!includePhylogeny){
  rho <- 0
  iW <- solve(diag(ns))
  ldetW <- log(det(diag(ns)))
}

## Initial likelihoods for THETA
li1 <- numeric(ns)

for(k in 1: ns){
  li1[k] <- likelihood(theta = Theta[k, ], tracks = tracks[SPS == SP[k], ], s = s, f = f, d = d)
}

initliks <- data.frame(SP, li1) # initial likelihoods

## Acceptance rates
ac <- array(0, c(np, ns, 2))
kk <- array(1, c(np, ns)) # sd for the proposal distributions
acr <- array(NA, c(ns, np))

## Chain properties
adapt  <- 1000
n.iter <- 5000
thin <- 10
store <- seq(adapt, n.iter, thin)[-1]
npost <- length(store) # length of stored posteriors

## Posteriors to be stored
Post_Theta <- array(NA, c(ns, np, npost))
Post_Z <- array(NA, c(nt, np, npost))
Post_Sigma <- array(NA, c(np, np, npost))
Post_rho <- numeric(npost)

trunca <- function(x) min(max(x, 10^-5), 10^5)

```

##  MCMC sampling scheme

```{r}

tpm0 <- proc.time() #initial processing time

for (i in 1: n.iter){
  
  ## We use a Metropolis-Hastings step to sample the species-specific parameters (THETA)
  ## UPDATE THETA
  
  RES <- as.numeric(t(M)) - as.numeric(t(Theta))
  li2 <- -(1/2) * RES %*% kronecker(iW, iSI) %*% RES
  
  for (k in 1: ns){ # for each species
    for (l in 1: np){ # for each species-specific parameter
      NTHE <- Theta
      nthe <- Theta[k, ]

      nthe[l] <- nthe[l] + rnorm(1, mean = 0, sd = kk[l, k])
      NTHE[k, l] <- nthe[l]
      nli1 <- likelihood(theta = nthe, tracks = tracks[SPS == SP[k], ], s = s, f = f, d = d)
      RES  <- as.numeric(t(M)) - as.numeric(t(NTHE))
      nli2 <- -(1/2) * RES %*% kronecker(iW, iSI) %*% RES
      ac[l, k, 1] <- ac[l, k, 1] + 1
      
      if(is.finite(nli1) & is.finite(nli2)){
        ##set.seed(42)
        if(runif(1) < exp((nli1 - li1[k] + nli2 - li2))){
          Theta[k, ] <- nthe
          li1[k] <- nli1
          li2 <- nli2
          ac[l, k, 2] <- ac[l, k, 2] + 1
        }
      }
    }
  }
  
  ## The other parameters are sampled directly from their full conditional distribution 
  
  ## UPDATE Z
  
  XTHE <- as.vector(t(Theta)) # transform to vector by line
  iXSI <- iW %x% iSI
  Vs <- solve(solve(S_z) + t(X) %*% iXSI %*% X)
  Vs <- (Vs + t(Vs))/2
  mus <- Vs %*% (solve(S_z) %*% mu_z + t(X) %*% iXSI %*% XTHE)
  # set.seed(42)
  Z <- matrix(rmvnorm(1, mean = mus, sigma = Vs), ncol = np, byrow = TRUE)
  M <- TT %*% Z
  
  ## UPDATE Sigma
  
  RES <- Theta - M
  A <- t(RES) %*% iW %*% RES
  PSIA <- PSI + A
  PSIA <- (PSIA + t(PSIA))/2
  ##set.seed(42)
  Sigma <- riwish((nu+ns), PSIA) # Inverse Wishart Matrix Distribution
  Sigma <- (Sigma + t(Sigma))/2
  iSI <- solve(Sigma)
  
  ## UPDATE rho
  
  if(includePhylogeny){
    RES <- as.numeric(t(M)) - as.numeric(t(Theta))
    likeRho <- numeric(nr)
    for(ii in 1:nr){
      likeRho[ii] <- (-1/2)*(np*ldetWs[ii] + RES%*%(iWs[,,ii] %x% iSI)%*%RES)
    }
    postRho <- lpriorRho + likeRho
    pr <- exp(postRho)/sum(exp(postRho))
    RI <- sample(seq(1:nr),size=1,prob=pr)
    iW <- iWs[,,RI]
    ldetW <- ldetWs[RI]
    rho <- rhos[RI]
  }
  
  ## Store the posteriors
  if(i %in% store) {
    print(i)
    Post_Theta[ , , which(store == i)] <- Theta
    Post_Z[ , , which(store == i)] <- Z
    Post_Sigma[ , , which(store == i)] <- Sigma
    Post_rho[which(store == i)] <- rho
  }
  
  ## Adaptation (adjusting the variance of the proposal distribution)
  for (h in 1: ns){
    q <- 1 + exp(-i/500)
    w <- 1 - 0.1*exp(-i/500)
    acr[h, ] <- ac[ , h, 2]/ac[ , h, 1]
    
    if(i <= adapt){
      kk[ , h] <- sapply(kk[ , h] * q^(acr[h, ] - 0.44), trunca)
      ac <- ac * w
    }
  }
}

tpm1 <- proc.time() #final time
```

## Results

Here, we organize a summary of the MCMC sampling scheme output and provide the code of the Figure 2 of the manuscript, with the influence of species traits on species-specific movement parameters. The panels show the posterior mean (dot) and 95% credibility intervals of the movement parameters describing the mean movement distance $\log \mathbf{\alpha_k}$ (left),  affinity to semi-open habitat $\mathbf{\beta^s_k}$ (center), and affinity to forest $\mathbf{\beta^f_k}$ (right) for each species k. The continuous lines show the posterior mean prediction of expected movement parameters based on species traits. The colors indicate omnivorous (green), granivorous (blue), frugivorous (black), and insectivorous birds (red). The dashed horizontal line in panels B and C shows the zero lines, thus values above the line correspond to birds that prefer corridor or forest habitats more than open habitats.

```{r}

## MCMC summary

(dtpm <- (tpm1[3] - tpm0[3])/60) # processing time

rnames_summary <- c("Time elapsed (minutes):", "Number of iterations:",
                    "Number of adaptation iterations:","Length of recorded posteriors",
                    "Number of species", "Number of parameters", "Number of traits")
(results_summary <- matrix(c(as.numeric(dtpm), n.iter, adapt, npost, ns, np, nt),
                          dimnames = list(rnames_summary,"Output summary")))

## Table with initial and final likelihoods of THETA for each species

likelihoods <- cbind(initliks,li1) 
colnames(likelihoods) <- c("Species", "InitialLikelihood", "FinalLikelihood")

posteriors <- list(Post_Theta = Post_Theta, Post_Z = Post_Z, Post_Sigma = Post_Sigma, Post_rho = Post_rho)

## Figure 2. Influence of species traits on species-specific movement parameters

mass <- TT[,5]
tgroup <- ttraits[,2]
meZT <- apply(Post_Z,FUN = mean, MARGIN=1:2) # means for the posterior values of Zeta

tiff(filename="fig2.tif", res=300, unit="cm", height=10, width=30)
par(mfrow = c(1,3), oma=c(0,0,0,0),mar=c(5,5,3,1))

for (k in 1: np){

  me <- rowMeans(Post_Theta[,k,])
  lo <- apply(Post_Theta[,k,], MARGIN = 1,FUN = quantile, probs = 0.25)
  hi <- apply(Post_Theta[,k,], MARGIN = 1,FUN = quantile, probs = 0.75)

  if (k == 1) {plot(1, type="n", xlab="", ylab="",
              xlim=c(2, 6),
              ylim=c(-0.5, 2),
              cex=2.5,xaxt="n",yaxt="n",
              bty="n")
  } else {plot(1, type="n", xlab="", ylab="",
             xlim=c(2, 6),
             ylim=c(-0.5, 5.5),
             cex=2.5,xaxt="n",yaxt="n",
             bty="n")}
  box(bty="o", col="gray35")
  axis(1,cex.axis=1.6, col = "gray35",col.axis="gray35", las = 1,tck=-0.01,mgp = c(2, 0.5, 0),
       lwd = 1,at = seq(2,6,1))
  axis(2, cex.axis = 1.6, col = "gray35", col.axis="gray35", las = 1, tck=-0.01, mgp = c(3, 0.4, 0), lwd = 1)
  title(xlab ="log body mass (g)", line = 2.3,cex.lab=2)
  title(ylab = parameters[k], line = 2.5,cex.lab=2)
  if (k > 1) abline(h=0, lty=5,col = "gray35")

  for(i in 1: length(unique(tgroup))) {

    pdit = unique(tgroup)[i]

    T1 <- matrix(0,ncol=nt, nrow=2)
    T1[1, nt] <- min(mass)
    T1[2, nt] <- max(mass)
    T1[1, pdit] <- 1
    T1[2, pdit] <- 1
    pre <- T1 %*% meZT
    lines(pre[,k] ~ c(min(mass), max(mass)), col = as.numeric(pdit))

    points(me[tgroup == pdit] ~ mass[tgroup == pdit], pch = 16, col = as.numeric(pdit))
    segments(mass[tgroup == pdit], lo[tgroup == pdit],mass[tgroup == pdit], hi[tgroup == pdit], col = as.numeric(pdit))
    ## colors: black (frugivorous); red (insectivorous); green (omnivorous); blue (granivorous)
  }

}

dev.off()
```

We also compare the estimated parameters between each pair of feeding classes by calculating the probability for one feeding class having a higher parameter value than the other feeding class (measured as the difference in the Zeta parameters being either positive or negative).

```{r}
## Posterior probability of differences between feeding classes

dif <- array(NA,c(6,np,npost))
comb <- data.frame(c(1,2),c(1,3),c(1,4),c(2,3),c(2,4),c(3,4))

for (i in 1: npost){ #for each iteration
  T1 <- matrix(0, ncol = nt, nrow = length(unique(tgroup)))
  for (k in 1: length(unique(tgroup))){
    pdit <- unique(tgroup)[k]
    T1[pdit,nt] <- min(mass)
    T1[pdit,pdit] <- 1
  }
  pre <- T1 %*% POST_ZT[ , , i]
  for (k in 1: length(comb)){
    dif[k,,i] <- pre[comb[2, k], ] - pre[comb[1, k], ]
  }
}

dif[which(dif > 0)] <- 1
dif[which(dif < 0)] <- 0

postpr <- matrix(nrow = 6, ncol = np)
for (i in 1: length(comb)){
  postpr[i, ] <- rowSums(dif[i, , ])
}

postpr <- postpr/npost
colnames(postpr) <- parameters
rownames(postpr) <- c("ins-frug","omn-frug","grn-frug","omn-ins","grn-ins","grn-omn")

write.table(postpr, file="posteriors_probability.csv", sep=",")
```

